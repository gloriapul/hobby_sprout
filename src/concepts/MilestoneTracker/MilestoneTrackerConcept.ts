import { Collection, Db } from "mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "@utils/gemini-llm.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "MilestoneTracker" + ".";

// Generic types for this concept
type User = ID;
type Goal = ID; // for a specific goal document
type Step = ID; // for a specific step document

/**
 * State:
 * a set of Goals with
 *  a user of type User
 *  a description of type String
 *  an isActive of type Boolean
 */
interface GoalDoc {
  _id: Goal;
  user: User; // who owns this goal
  description: string;
  hobby: string; // hobby associated with this goal
  isActive: boolean;
}

/**
 * a set of Steps with
 *  a goalId of type Goal
 *  a description of type String,
 *  a start of type Date
 *  a completion? of type Date
 *  an isComplete of type Boolean
 */
interface StepDoc {
  _id: Step;
  goalId: Goal; // reference to the Goal this step belongs to
  description: string;
  start: Date;
  completion?: Date; // date when the step was completed
  isComplete: boolean;
}

/**
 * @concept MilestoneTracker
 * @purpose allow users to monitor the progress that they are making toward their goals.
 * @principle after a user inputs their goal, they will have the option of having an LLM generate their
 * list of recommended steps or will be able to input their own. They can then mark steps as complete,
 * and will be allowed to see those that they have yet to complete and those that have been completed.
 */
export default class MilestoneTrackerConcept {
  private goals: Collection<GoalDoc>;
  private steps: Collection<StepDoc>;
  private llm: GeminiLLM | null = null;
  private apiKey: string | null = null;

  constructor(private readonly db: Db, apiKey?: string) {
    this.goals = this.db.collection(PREFIX + "goals");
    this.steps = this.db.collection(PREFIX + "steps");
    this.apiKey = apiKey || null;

    // initialize LLM if API key is provided
    if (this.apiKey) {
      this.initializeLLM(this.apiKey);
    }
  }

  /**
   * Helper: initializes the LLM with the provided API key
   */
  initializeLLM(apiKey: string): void {
    try {
      this.llm = new GeminiLLM({ apiKey });
    } catch (error) {
      console.warn("Failed to initialize LLM:", error);
      this.llm = null;
    }
  }

  /**
   * Helper: validates the quality and structure of steps generated by the LLM
   * @returns error message if validation fails, undefined if successful
   */
  private validateStepQuality(steps: string[]): string | undefined {
    // 1. Length validation (10-300 characters)
    for (const step of steps) {
      if (step.length < 10) {
        return `Step too brief: "${step}". Provide more detail to clarify the action.`;
      }
      if (step.length > 300) {
        return `Step too detailed: "${step}". Keep each step brief and focused on one main action.`;
      }
    }

    // 2. Vague language check (whole words only)
    const vagueWords = ["etc", "maybe", "possibly", "as necessary"];
    for (const step of steps) {
      for (const word of vagueWords) {
        // Use regex to match whole words only
        const re = new RegExp(
          `\\b${word.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\b`,
          "i",
        );
        if (re.test(step)) {
          return `Vague step detected: "${step}". Steps must be specific and actionable.`;
        }
      }
    }

    // 3. Verbosity check (no more than 6 commas)
    for (const step of steps) {
      const commaCount = (step.match(/,/g) || []).length;
      if (commaCount > 6) {
        return `Step too verbose: "${step}". Break into simpler steps.`;
      }
    }

    // Passed all checks
    return undefined;
  }

  /**
   * createGoal (user: User, description: String)
   *
   * @requires no active `Goal` for this `user` already exists. `description` is not an empty string.
   *
   * @effects creates a new `Goal` `g`; sets its `user` to `user` and `description` to `description`;
   * sets `isActive` to `true`; returns `g` as `goal`.
   */
  async createGoal({
    user,
    description,
    hobby,
    autoGenerate,
  }: {
    user: User;
    description: string;
    hobby: string;
    autoGenerate?: boolean;
  }): Promise<{ goalId: string } | { error: string }> {
    if (!description || description.trim() === "") {
      return { error: "Goal description cannot be empty." };
    }
    if (!hobby || hobby.trim() === "") {
      return { error: "Hobby cannot be empty when creating a goal." };
    }

    // check if an active goal already exists for this user and hobby
    const existingGoal = await this.goals.findOne({
      user,
      hobby,
      isActive: true,
    });
    if (existingGoal) {
      return {
        error:
          `An active goal already exists for user ${user} and hobby ${hobby}. Please close it first.`,
      };
    }

    const newGoalId = freshID();
    const newGoal: GoalDoc = {
      _id: newGoalId,
      user,
      description: description.trim(),
      hobby: hobby.trim(),
      isActive: true,
    };

    try {
      await this.goals.insertOne(newGoal);
      return { goalId: newGoalId };
    } catch (e) {
      return {
        error: `Failed to create goal: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * generateSteps (goal: Goal): (steps: Step[])
   *
   * @requires `goal` exists and is active; no `Steps` are currently associated with this `goal`.
   *
   * @effects uses gemini LLM to generate `Step` descriptions based on the `goal`'s description;
   * for each generated description, creates a new `Step` associated with `goal`, sets `description`,
   * `start` (current date), and `isComplete` to `false`; returns the IDs of the created `Steps` as an array `steps`.
   */
  /**
   * Helper: generates steps for a goal using the LLM.
   */
  private async _generateStepsFromLLM(
    goal: Goal,
    targetGoal: GoalDoc,
  ): Promise<{ steps: Step[] } | { error: string }> {
    if (!this.llm) {
      return {
        error: "LLM not initialized. API key might be missing or invalid.",
      };
    }

    try {
      const llmPrompt = `
        You are a helpful AI assistant that creates a recommended plan of clear steps for people looking to work on a hobby.

        The user's hobby is: "${targetGoal.hobby}"
        Create a structured step-by-step plan for this goal: "${targetGoal.description}"

        Response Requirements:
        1. Return ONLY a single-line JSON array of strings
        2. Each string should be a specific, complete, measurable, and actionable step
        3. Steps must be relevant to the hobby and the goal, and feasible for an average person (not overly ambitious or vague)
        4. Only contain necessary steps to achieve the goal, avoid filler steps and be mindful of number of steps generated
        5. Steps must be in logical order
        6. Do NOT use line breaks or extra whitespace
        7. Properly escape any quotes in the text
        8. No step numbers or prefixes
        9. No comments or explanations

        Example response format:
        ["Research camera settings and features","Practice taking photos in different lighting","Review and organize test shots"]

        Return ONLY the JSON array, nothing else.`;

      const responseText = await this.llm.executeLLM(llmPrompt);

      let stepDescriptions: string[];
      try {
        stepDescriptions = JSON.parse(responseText);
      } catch (_parseError) {
        return {
          error: "Failed to parse LLM response as JSON array.",
        };
      }

      if (
        !Array.isArray(stepDescriptions) ||
        stepDescriptions.some((d) => typeof d !== "string")
      ) {
        return {
          error:
            "LLM returned invalid step format. Expected a JSON array of strings.",
        };
      }

      const validationError = this.validateStepQuality(stepDescriptions);
      if (validationError) {
        return { error: validationError };
      }

      const newStepDocs: StepDoc[] = stepDescriptions.map((desc) => ({
        _id: freshID(),
        goalId: goal,
        description: desc.trim(),
        start: new Date(),
        isComplete: false,
      }));

      if (newStepDocs.length > 0) {
        await this.steps.insertMany(newStepDocs);
      }

      return { steps: newStepDocs.map((s) => s._id) };
    } catch (e: unknown) {
      let llmErrorMessage = "LLM generation failed.";
      if (typeof e === "object" && e !== null && "message" in e) {
        llmErrorMessage = `Failed to generate steps: ${e.message}`;
      } else if (typeof e === "string") {
        llmErrorMessage = `Failed to generate steps: ${e}`;
      }
      return { error: llmErrorMessage };
    }
  }

  /**
   * generateSteps (goal: Goal): (steps: Step[])
   *
   * @requires `goal` exists and is active; no `Steps` are currently associated with this `goal`.
   *
   * @effects uses gemini LLM to generate `Step` descriptions based on the `goal`'s description;
   * for each generated description, creates a new `Step` associated with `goal`, sets `description`,
   * `start` (current date), and `isComplete` to `false`; returns the IDs of the created `Steps` as an array `steps`.
   */
  async generateSteps({
    goal,
    user,
  }: {
    goal: Goal;
    user: User;
  }): Promise<{ steps: Step[] } | { error: string }> {
    const targetGoal = await this.goals.findOne({
      _id: goal,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      return {
        error:
          `Goal ${goal} not found, is not active, or you do not have permission.`,
      };
    }

    const existingStepsCount = await this.steps.countDocuments({
      goalId: goal,
    });
    if (existingStepsCount > 0) {
      return {
        error:
          `Steps already exist for goal ${goal}. Cannot generate new ones.`,
      };
    }

    return this._generateStepsFromLLM(goal, targetGoal);
  }

  /**
   * addStep (goal: Goal, description: String): (step: Step)
   *
   * @requires: `goal` exists and is active; `description` is not an empty string.
   *
   * @effects: creates a new `Step` `s`; sets `goalId` to `goal`, `description` to `description`,
   * `start` to current date, and `isComplete` to `false`; returns `s` as `step`.
   */
  async addStep({
    goal,
    description,
    user,
  }: {
    goal: Goal;
    description: string;
    user: User;
  }): Promise<{ step: Step } | { error: string }> {
    if (!description || description.trim() === "") {
      return { error: "Step description cannot be empty." };
    }

    const targetGoal = await this.goals.findOne({
      _id: goal,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      return { error: "Cannot add steps to an inactive or unauthorized goal." };
    }

    // validate the quality of the manually added step
    const validationError = this.validateStepQuality([description]);
    if (validationError) {
      return { error: validationError };
    }

    // Check for existing step with same goal and description
    const existingStep = await this.steps.findOne({
      goalId: goal,
      description: description.trim(),
    });
    if (existingStep) {
      // Return the existing step's ID
      return { step: existingStep._id };
    }

    const newStepId = freshID();
    const newStep: StepDoc = {
      _id: newStepId,
      goalId: goal,
      description: description.trim(),
      start: new Date(),
      isComplete: false,
    };

    try {
      await this.steps.insertOne(newStep);
      return { step: newStepId };
    } catch (e) {
      return {
        error: `Failed to add step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * completeStep (step: Step)
   *
   * @requires `step` exists and is not already complete. The `Goal` associated with `step` is active.
   *
   * @effects sets `isComplete` of `step` to `true`; sets `completion` date to current date.
   */
  async completeStep({
    step,
    user,
  }: {
    step: Step;
    user: User;
  }): Promise<Empty | { error: string }> {
    console.debug("[completeStep] called", { step, user });
    const targetStep = await this.steps.findOne({ _id: step });
    if (!targetStep) {
      console.warn(`[completeStep] Step not found: ${step}`);
      return { error: `Step ${step} not found.` };
    }
    if (targetStep.isComplete) {
      console.warn(`[completeStep] Step already complete: ${step}`);
      return { error: `Step ${step} is already complete.` };
    }

    const targetGoal = await this.goals.findOne({
      _id: targetStep.goalId,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      console.warn(`[completeStep] Goal not active or no permission for user`, {
        goalId: targetStep.goalId,
        user,
      });
      return {
        error:
          `Goal associated with step ${step} is not active or you do not have permission. Cannot complete step.`,
      };
    }

    try {
      const updateResult = await this.steps.updateOne(
        { _id: step },
        { $set: { isComplete: true, completion: new Date() } },
      );
      if (updateResult.modifiedCount !== 1) {
        console.error(`[completeStep] Failed to update step: ${step}`);
        return { error: `Failed to update step ${step}.` };
      }
      console.debug(`[completeStep] Step completed: ${step}`);
      return {};
    } catch (e) {
      console.error(`[completeStep] Exception:`, e);
      return {
        error: `Failed to complete step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * removeStep (step: Step)
   *
   * @requires `step` exists; `step` is not complete; the `Goal` associated with `step` is active.
   *
   * @effects deletes the `step` document from storage.
   */
  async removeStep({
    step,
    user,
  }: {
    step: Step;
    user: User;
  }): Promise<Empty | { error: string }> {
    const targetStep = await this.steps.findOne({ _id: step });
    if (!targetStep) {
      return { error: `Step ${step} not found.` };
    }
    if (targetStep.isComplete) {
      return { error: `Cannot remove completed step ${step}.` };
    }

    const targetGoal = await this.goals.findOne({
      _id: targetStep.goalId,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      return {
        error:
          `Goal associated with step ${step} is not active or you do not have permission. Cannot remove step.`,
      };
    }

    try {
      const res = await this.steps.deleteOne({ _id: step });
      if (res.deletedCount !== 1) {
        return { error: `Failed to remove step ${step}.` };
      }
      return {};
    } catch (e) {
      return {
        error: `Failed to remove step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * closeGoal (goal: Goal)
   *
   * @requires `goal` exists and is active.
   *
   * @effects sets `isActive` of `goal` to `false`.
   */
  async closeGoal({
    goal,
    user,
  }: {
    goal: Goal;
    user: User;
  }): Promise<Empty | { error: string }> {
    console.debug("[closeGoal] called", { goal, user });
    const targetGoal = await this.goals.findOne({
      _id: goal,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      console.warn(`[closeGoal] Goal not found, not active, or no permission`, {
        goal,
        user,
      });
      return {
        error:
          `Goal ${goal} not found, is not active, or you do not have permission.`,
      };
    }

    try {
      const updateResult = await this.goals.updateOne({ _id: goal }, {
        $set: { isActive: false },
      });
      if (updateResult.modifiedCount !== 1) {
        console.error(`[closeGoal] Failed to update goal: ${goal}`);
        return { error: `Failed to close goal ${goal}.` };
      }
      console.debug(`[closeGoal] Goal closed: ${goal}`);
      return {};
    } catch (e) {
      console.error(`[closeGoal] Exception:`, e);
      return {
        error: `Failed to close goal: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * _getGoal (user: User, hobby?: string): (goal: {id: Goal, description: String, hobby: string, isActive: Boolean})[]
   *
   * @requires `user` exists.
   *
   * @effects returns an array containing the active `Goal`(s) for the `user` (optionally filtered by hobby), including its `id`, `description`, `hobby`, and `isActive` status.
   */
  async _getGoal({
    user,
    hobby,
  }: {
    user: User;
    hobby?: string;
  }): Promise<
    { id: Goal; description: string; hobby: string; isActive: boolean }[]
  > {
    const query: { user: User; hobby?: string } = { user };
    if (hobby) query.hobby = hobby;
    const goalDocs = await this.goals.find(query).toArray();
    return goalDocs.map((goalDoc) => ({
      id: goalDoc._id,
      description: goalDoc.description,
      hobby: goalDoc.hobby,
      isActive: goalDoc.isActive,
    }));
  }

  /**
   * getGoals (user: User): (goal: {id: Goal, description: string, hobby: string, isActive: boolean})[]
   *
   * @requires `user` exists.
   *
   * @effects returns an array containing all active goals for the `user` without hobby filtering, including its `id`, `description`, `hobby`, and `isActive` status.
   */
  async _getGoals({
    user,
  }: {
    user: User;
  }): Promise<
    { id: Goal; description: string; hobby: string; isActive: boolean }[]
  > {
    const query: { user: User } = { user };
    const goalDocs = await this.goals.find(query).toArray();
    return goalDocs.map((goalDoc) => ({
      id: goalDoc._id,
      description: goalDoc.description,
      hobby: goalDoc.hobby,
      isActive: goalDoc.isActive,
    }));
  }

  /**
   * _getSteps (goal: Goal): (step: {id: Step, description: String, start: Date, completion: Date?, isComplete: Boolean})[]
   *
   * @requires `goal` exists.
   *
   * @effects Returns an array of all `Steps` for the given `goal`, including their details.
   */
  async _getSteps({
    goal,
  }: {
    goal: Goal;
  }): Promise<
    {
      id: Step;
      description: string;
      start: Date;
      completion?: Date;
      isComplete: boolean;
    }[]
  > {
    const stepsDocs = await this.steps.find({ goalId: goal }).toArray();
    return stepsDocs.map((s) => ({
      id: s._id,
      description: s.description,
      start: s.start,
      completion: s.completion,
      isComplete: s.isComplete,
    }));
  }

  /**
   * regenerateSteps (goal: Goal): (steps: Step[])
   *
   * @requires `goal` exists and is active
   *
   * @effects deletes all existing steps for the goal, then generates new steps using the LLM.
   * Returns the IDs of the new steps as an array `steps`.
   */
  async regenerateSteps({
    goal,
    user,
  }: {
    goal: Goal;
    user: User;
  }): Promise<{ steps: Step[] } | { error: string }> {
    const targetGoal = await this.goals.findOne({
      _id: goal,
      isActive: true,
      user,
    });
    if (!targetGoal) {
      return {
        error:
          `Goal ${goal} not found, is not active, or you do not have permission.`,
      };
    }
    await this.steps.deleteMany({ goalId: goal });

    return this._generateStepsFromLLM(goal, targetGoal);
  }
}
