import { Collection, Db } from "mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "@utils/gemini-llm.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "MilestoneTracker" + ".";

// Generic types for this concept
type User = ID;
type Goal = ID; // for a specific goal document
type Step = ID; // for a specific step document

/**
 * State:
 * a set of Goals with
 *  a user of type User
 *  a description of type String
 *  an isActive of type Boolean
 */
interface GoalDoc {
  _id: Goal;
  user: User; // who owns this goal
  description: string;
  isActive: boolean;
}

/**
 * a set of Steps with
 *  a goalId of type Goal
 *  a description of type String,
 *  a start of type Date
 *  a completion? of type Date
 *  an isComplete of type Boolean
 */
interface StepDoc {
  _id: Step;
  goalId: Goal; // reference to the Goal this step belongs to
  description: string;
  start: Date;
  completion?: Date; // date when the step was completed
  isComplete: boolean;
}

/**
 * @concept MilestoneTracker
 * @purpose allow users to monitor the progress that they are making toward their goals.
 * @principle after a user inputs their goal, they will have the option of having an LLM generate their
 * list of recommended steps or will be able to input their own. They can then mark steps as complete,
 * and will be allowed to see those that they have yet to complete and those that have been completed.
 */
export default class MilestoneTrackerConcept {
  private goals: Collection<GoalDoc>;
  private steps: Collection<StepDoc>;
  private llm: GeminiLLM | null = null;
  private apiKey: string | null = null;

  constructor(private readonly db: Db, apiKey?: string) {
    this.goals = this.db.collection(PREFIX + "goals");
    this.steps = this.db.collection(PREFIX + "steps");
    this.apiKey = apiKey || null;

    // initialize LLM if API key is provided
    if (this.apiKey) {
      this.initializeLLM(this.apiKey);
    }
  }

  /**
   * Helper: initializes the LLM with the provided API key
   */
  initializeLLM(apiKey: string): void {
    try {
      this.llm = new GeminiLLM({ apiKey });
    } catch (error) {
      console.warn("Failed to initialize LLM:", error);
      this.llm = null;
    }
  }

  /**
   * Helper: validates the quality and structure of steps generated by the LLM
   * @returns error message if validation fails, undefined if successful
   */
  private validateStepQuality(steps: string[]): string | undefined {
    // 1. Length validation (10-300 characters)
    for (const step of steps) {
      if (step.length < 10) {
        return `Step too brief: "${step}". Provide more detail to clarify the action.`;
      }
      if (step.length > 300) {
        return `Step too detailed: "${step}". Keep each step brief and focused on one main action.`;
      }
    }

    // 2. Vague language check
    const vagueWords = ["etc", "maybe", "possibly", "and more", "as necessary"];
    for (const step of steps) {
      for (const word of vagueWords) {
        if (step.toLowerCase().includes(word)) {
          return `Vague step detected: "${step}". Steps must be specific and actionable.`;
        }
      }
    }

    // 3. Verbosity check (no more than 6 commas)
    for (const step of steps) {
      const commaCount = (step.match(/,/g) || []).length;
      if (commaCount > 6) {
        return `Step too verbose: "${step}". Break into simpler steps.`;
      }
    }

    return undefined; // passed
  }

  /**
   * createGoal (user: User, description: String)
   *
   * @requires no active `Goal` for this `user` already exists. `description` is not an empty string.
   *
   * @effects creates a new `Goal` `g`; sets its `user` to `user` and `description` to `description`;
   * sets `isActive` to `true`; returns `g` as `goal`.
   */
  async createGoal({
    user,
    description,
  }: {
    user: User;
    description: string;
  }): Promise<{ goal: Goal } | { error: string }> {
    if (!description || description.trim() === "") {
      return { error: "Goal description cannot be empty." };
    }

    // check if an active goal already exists for this user
    const existingGoal = await this.goals.findOne({ user, isActive: true });
    if (existingGoal) {
      return {
        error:
          `An active goal already exists for user ${user}. Please close it first.`,
      };
    }

    const newGoalId = freshID();
    const newGoal: GoalDoc = {
      _id: newGoalId,
      user,
      description: description.trim(),
      isActive: true,
    };

    try {
      await this.goals.insertOne(newGoal);
      return { goal: newGoalId };
    } catch (e) {
      console.error("Error creating goal:", e);
      return {
        error: `Failed to create goal: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * generateSteps (goal: Goal): (steps: Step[])
   *
   * @requires `goal` exists and is active; no `Steps` are currently associated with this `goal`.
   *
   * @effects uses gemini LLM to generate `Step` descriptions based on the `goal`'s description;
   * for each generated description, creates a new `Step` associated with `goal`, sets `description`,
   * `start` (current date), and `isComplete` to `false`; returns the IDs of the created `Steps` as an array `steps`.
   */
  async generateSteps({
    goal,
  }: {
    goal: Goal;
  }): Promise<{ steps: Step[] } | { error: string }> {
    const targetGoal = await this.goals.findOne({ _id: goal, isActive: true });
    if (!targetGoal) {
      return { error: `Goal ${goal} not found or is not active.` };
    }

    // check if set of steps already exist for this goal
    const existingStepsCount = await this.steps.countDocuments({
      goalId: goal,
    });
    if (existingStepsCount > 0) {
      return {
        error:
          `Steps already exist for goal ${goal}. Cannot generate new ones.`,
      };
    }

    // check if LLM is initialized
    if (!this.llm) {
      return {
        error: "LLM not initialized. API key might be missing or invalid.",
      };
    }

    try {
      const llmPrompt = `
        You are a helpful AI assistant that creates a recommended plan of clear steps for people looking to work on a hobby.

        Create a structured step-by-step plan for this goal: "${targetGoal.description}"

        Response Requirements:
        1. Return ONLY a single-line JSON array of strings
        2. Each string should be a specific, complete, measurable, and actionable step
        3. Step must be relevant to the goal and feasible for an average person, should not be overly ambitious or vague
        4. Only contain necessary steps to achieve the goal, avoid filler steps and be mindful of number of steps generated
        5. Steps must be in logical order
        6. Do NOT use line breaks or extra whitespace
        7. Properly escape any quotes in the text
        8. No step numbers or prefixes
        9. No comments or explanations

        Example response format:
        ["Research camera settings and features","Practice taking photos in different lighting","Review and organize test shots"]

        Return ONLY the JSON array, nothing else.`;

      const responseText = await this.llm.executeLLM(llmPrompt);

      let stepDescriptions: string[];
      try {
        stepDescriptions = JSON.parse(responseText);
      } catch (_parseError) {
        return {
          error: "Failed to parse LLM response as JSON array.",
        };
      }

      if (
        !Array.isArray(stepDescriptions) ||
        stepDescriptions.some((d) => typeof d !== "string")
      ) {
        return {
          error:
            "LLM returned invalid step format. Expected a JSON array of strings.",
        };
      }

      // step quality
      const validationError = this.validateStepQuality(stepDescriptions);
      if (validationError) {
        return { error: validationError };
      }

      const newStepDocs: StepDoc[] = stepDescriptions.map((desc) => ({
        _id: freshID(),
        goalId: goal,
        description: desc.trim(),
        start: new Date(),
        isComplete: false,
      }));

      if (newStepDocs.length > 0) {
        await this.steps.insertMany(newStepDocs);
      }

      return { steps: newStepDocs.map((s) => s._id) };
    } catch (e: unknown) {
      console.error("Error generating steps with LLM:", e);
      let llmErrorMessage = "LLM generation failed.";
      if (typeof e === "object" && e !== null && "message" in e) {
        llmErrorMessage = `Failed to generate steps: ${e.message}`;
      } else if (typeof e === "string") {
        llmErrorMessage = `Failed to generate steps: ${e}`;
      }
      return { error: llmErrorMessage };
    }
  }

  /**
   * addStep (goal: Goal, description: String): (step: Step)
   *
   * @requires: `goal` exists and is active; `description` is not an empty string.
   *
   * @effects: creates a new `Step` `s`; sets `goalId` to `goal`, `description` to `description`,
   * `start` to current date, and `isComplete` to `false`; returns `s` as `step`.
   */
  async addStep({
    goal,
    description,
  }: {
    goal: Goal;
    description: string;
  }): Promise<{ step: Step } | { error: string }> {
    if (!description || description.trim() === "") {
      return { error: "Step description cannot be empty." };
    }

    const targetGoal = await this.goals.findOne({ _id: goal, isActive: true });
    if (!targetGoal) {
      return { error: "Cannot add steps to an inactive goal." };
    }

    // validate the quality of the manually added step
    const validationError = this.validateStepQuality([description]);
    if (validationError) {
      return { error: validationError };
    }

    const newStepId = freshID();
    const newStep: StepDoc = {
      _id: newStepId,
      goalId: goal,
      description: description.trim(),
      start: new Date(),
      isComplete: false,
    };

    try {
      await this.steps.insertOne(newStep);
      return { step: newStepId };
    } catch (e) {
      console.error("Error adding step:", e);
      return {
        error: `Failed to add step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * completeStep (step: Step)
   *
   * @requires `step` exists and is not already complete. The `Goal` associated with `step` is active.
   *
   * @effects sets `isComplete` of `step` to `true`; sets `completion` date to current date.
   */
  async completeStep(
    { step }: { step: Step },
  ): Promise<Empty | { error: string }> {
    const targetStep = await this.steps.findOne({ _id: step });
    if (!targetStep) {
      return { error: `Step ${step} not found.` };
    }
    if (targetStep.isComplete) {
      return { error: `Step ${step} is already complete.` };
    }

    const targetGoal = await this.goals.findOne({
      _id: targetStep.goalId,
      isActive: true,
    });
    if (!targetGoal) {
      return {
        error:
          `Goal associated with step ${step} is not active. Cannot complete step.`,
      };
    }

    try {
      await this.steps.updateOne(
        { _id: step },
        { $set: { isComplete: true, completion: new Date() } },
      );
      return {};
    } catch (e) {
      console.error("Error completing step:", e);
      return {
        error: `Failed to complete step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * removeStep (step: Step)
   *
   * @requires `step` exists; `step` is not complete; the `Goal` associated with `step` is active.
   *
   * @effects deletes the `step` document from storage.
   */
  async removeStep(
    { step }: { step: Step },
  ): Promise<Empty | { error: string }> {
    const targetStep = await this.steps.findOne({ _id: step });
    if (!targetStep) {
      return { error: `Step ${step} not found.` };
    }
    if (targetStep.isComplete) {
      return { error: `Cannot remove completed step ${step}.` };
    }

    const targetGoal = await this.goals.findOne({
      _id: targetStep.goalId,
      isActive: true,
    });
    if (!targetGoal) {
      return {
        error:
          `Goal associated with step ${step} is not active. Cannot remove step.`,
      };
    }

    try {
      const res = await this.steps.deleteOne({ _id: step });
      if (res.deletedCount !== 1) {
        return { error: `Failed to remove step ${step}.` };
      }
      return {};
    } catch (e) {
      console.error("Error removing step:", e);
      return {
        error: `Failed to remove step: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * closeGoal (goal: Goal)
   *
   * @requires `goal` exists and is active.
   *
   * @effects sets `isActive` of `goal` to `false`.
   */
  async closeGoal(
    { goal }: { goal: Goal },
  ): Promise<Empty | { error: string }> {
    const targetGoal = await this.goals.findOne({ _id: goal, isActive: true });
    if (!targetGoal) {
      return { error: `Goal ${goal} not found or is not active.` };
    }

    try {
      await this.goals.updateOne({ _id: goal }, { $set: { isActive: false } });
      return {};
    } catch (e) {
      console.error("Error closing goal:", e);
      return {
        error: `Failed to close goal: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * _getGoal (user: User): (goal: {id: Goal, description: String, isActive: Boolean})[]
   *
   * @requires `user` exists.
   *
   * @effects returns an array containing the active `Goal` (if any) for the `user`, including its `id`, `description`, and `isActive` status.
   */
  async _getGoal({
    user,
  }: {
    user: User;
  }): Promise<{ id: Goal; description: string; isActive: boolean }[]> {
    const goalDoc = await this.goals.findOne({ user, isActive: true });
    if (!goalDoc) {
      return []; // return empty array if no active goal found
    }
    return [{
      id: goalDoc._id,
      description: goalDoc.description,
      isActive: goalDoc.isActive,
    }];
  }

  /**
   * _getSteps (goal: Goal): (step: {id: Step, description: String, start: Date, completion: Date?, isComplete: Boolean})[]
   *
   * @requires `goal` exists.
   *
   * @effects Returns an array of all `Steps` for the given `goal`, including their details.
   */
  async _getSteps({
    goal,
  }: {
    goal: Goal;
  }): Promise<
    {
      id: Step;
      description: string;
      start: Date;
      completion?: Date;
      isComplete: boolean;
    }[]
  > {
    const stepsDocs = await this.steps.find({ goalId: goal }).toArray();
    return stepsDocs.map((s) => ({
      id: s._id,
      description: s.description,
      start: s.start,
      completion: s.completion,
      isComplete: s.isComplete,
    }));
  }

  /**
   * _getIncompleteSteps (goal: Goal): (step: {id: Step, description: String, start: Date})[]
   *
   * @requires `goal` exists.
   *
   * @effects Returns an array of all incomplete `Steps` for the given `goal`, including their `id`, `description`, and `start` date.
   */
  async _getIncompleteSteps({
    goal,
  }: {
    goal: Goal;
  }): Promise<{ id: Step; description: string; start: Date }[]> {
    const stepsDocs = await this.steps.find({ goalId: goal, isComplete: false })
      .toArray();
    return stepsDocs.map((s) => ({
      id: s._id,
      description: s.description,
      start: s.start,
    }));
  }

  /**
   * _getCompleteSteps (goal: Goal): (step: {id: Step, description: String, start: Date, completion: Date})[]
   *
   * @requires `goal` exists.
   *
   * @effects Returns an array of all complete `Steps` for the given `goal`, including their `id`, `description`, `start` date, and `completion` date.
   */
  async _getCompleteSteps({
    goal,
  }: {
    goal: Goal;
  }): Promise<
    { id: Step; description: string; start: Date; completion: Date }[]
  > {
    const stepsDocs = await this.steps.find({ goalId: goal, isComplete: true })
      .toArray();
    return stepsDocs.filter((s) => s.completion !== undefined).map((s) => ({ // filter for completed steps with a completion date
      id: s._id,
      description: s.description,
      start: s.start,
      completion: s.completion!, // assert non-null after filtering
    }));
  }
}
